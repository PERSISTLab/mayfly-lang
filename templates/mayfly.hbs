/**
 * This file was autogenerated by the Mayfly compiler. 
 * DO NOT EDIT THE CONTENTS UNLESS YOU REALLY KNOW WHAT YOU ARE DOING.
 * 
 * Or have a perverse definition of "fun".
 * 
 * @author Josiah Hester <josiah@northwestern.edu>
 *
 */
 
/* ------------ C-lib & Programmer lib ---------- */
{{includes}}

/* ---------------- Mayfly State ---------------- */
#define STATE_NODE_IDLE 0
#define STATE_DEPENDANCIES_SATISFIED 1
#define STATE_NODE_COMPLETE 2
#define MAGIC_NUMBER 0xdeedbeef

/* ----- Helper methods for fast ring buffer ----- */

typedef struct {
	/* Number to verify start and end of a task */
	uint32_t magic_number;
	/* The last executing node */
	uint8_t current_node_id;
	/* Is the task node idle, ready, or complete */
	uint8_t node_status[{{num_tasks}}];
	/* Current global time from RTC or internal timer */
	uint32_t current_time;
	/* List of timestamps for last sample generation timestamp of each task  */
	uint32_t task_last_generation[{{num_tasks}}];
} mayfly_state_t;
mayfly_state_t __mayfly_state __attribute__ ((section ( ".nv" ))) = {MAGIC_NUMBER, 0, {0}, 0, {0}};


/* ----------------- Task Graphs ---------------- */
// Task Graph format
//	+----------------+ 
//	|  NODE_ID:NAME  |  [CONSTRAINTS]   
//	|    [inputs]    | ---------------> 
//	+----------------+ 
/* ---------------------------------------------- */
{{tasks}}

/* ---------------- User Tasks ------------------ */
{{usertasks}}

/* ------------- Task Data Structs -------------- */
{{task_data}}

/* ------------------ Helpers ------------------- */
{{helpers}}

/* ------------Main Program & Scheduler ---------- */
int main(void) {
  // Setup platform
  platform_init();
  uint32_t rtc_time = get_time();
  uint16_t timera_count = 0;
  // If RTC was reset, we must reset all timestamps
  if(was_rtc_reset_by_power_failure()) {
  	#ifdef DEBUG
		EIF_PRINTF("RTC reset\r\n");
	#endif
  	uint8_t ndx = 0;
  	{{#task_name_data}}
  	for(ndx=0;ndx<{{numitems}};ndx++) __{{name}}_output.timestamp[ndx] = 0;
  	__{{name}}_output.num=0;
  	{{/task_name_data}}
  	
  }
 
  // If reset before task completed, zero out that tasks recent output buffers
  if(__mayfly_state.magic_number != MAGIC_NUMBER) {
  	#ifdef DEBUG
		EIF_PRINTF("Rollback:%u\r\n", __mayfly_state.current_node_id);
	#endif
  	switch(__mayfly_state.current_node_id) {
		{{#task_name_data}}
  		case {{node_id}}:
  			// Remove newest data
  			if(__{{name}}_output.num > 0) {
  				__{{name}}_output.num--;
  				__{{name}}_output.timestamp[(__{{name}}_output.ndx + (~0)) & {{buffer_size_mask}}]=0;
  			}
  			// Reset out edge available flag
  			__{{name}}_output.status = 0;
  			break;
  		{{/task_name_data}}	
  	}
  }
  
  // Update the time since we were off
  __mayfly_state.current_time = rtc_time;
#ifdef DEBUG
   EIF_PRINTF("Power-on time: %u\r\n", rtc_time);
#endif
  
  // Main scheduler loop
  while(1) {
	// Get time
	timera_count += TA1R;
	if(timera_count >= ONE_SECOND_TIME_VLO) {
		timera_count = 0;
		__mayfly_state.current_time += 1;
	}
	
	// (re)start timer to time the loop body
	TA1CTL |= TACLR;
	TA1CCR0 = 65000;
#ifdef DEBUG
	EIF_PRINTF("t=%n.%u\r\n", __mayfly_state.current_time, timera_count);
#endif
{{scheduler}}
    // Sleep for a bit since we have nothing todo
    TA0CCR0 = SLEEP_TIME_100MILLISECONDS;     // Add Offset to TA0CCR0 to start counting
    __bis_SR_register(LPM3_bits + GIE);       // Enter LPM3 w/ interrupt
    __no_operation();                         // For debugger
  }
  return 0;
}

// Timer0_A0 interrupt service routine for scheduler sleep
void __attribute__ ((interrupt(TIMER0_A0_VECTOR))) Timer0_A0_ISR (void)
{
  TA0CTL |= TACLR;
  TA0CCR0 = 0; 							// Stop the timer
  __bic_SR_register_on_exit(LPM3_bits); // Exit to active CPU
}
